-- Stack machine.

import List;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  case i of
    READ      -> sprintf ("READ")
  | WRITE     -> sprintf ("WRITE")
  | BINOP (s) -> sprintf ("BINOP %s", s)
  | LD    (x) -> sprintf ("LD %s", x)
  | ST    (x) -> sprintf ("ST %s", x)
  | CONST (n) -> sprintf ("CONST %d", n)
  esac
}

public fun showSM (prg) {
  map (fun (i) {showSMInsn (i) ++ "\n"}, prg).stringcat
}

fun boMatch(op) {
  case op of
    "+"     -> fun (x, y) {x + y}           |
    "-"     -> fun (x, y) {x - y}           |
    "*"     -> fun (x, y) {x * y}           |
    "/"     -> fun (x, y) {x / y}           |
    ">"     -> fun (x, y) {x > y}           |
    "<"     -> fun (x, y) {x < y}           |
    ">="    -> fun (x, y) {x >= y}          |
    "<="    -> fun (x, y) {x <= y}          |
    "=="    -> fun (x, y) {x == y}          |
    "!="    -> fun (x, y) {x != y}          |
    "&&"    -> fun (x, y) {x && y}          |
    "!!"    -> fun (x, y) {x !! y}          |
    "%"     -> fun (x, y) {x % y}
  esac
}


-- запускаем одну 
fun runUnit ([stack, st, w], insn) {
  case insn of
    WRITE               -> case stack of
      n:ns          -> [ns, st, writeWorld(n, w)]
                           esac                                 |
    READ                -> case readWorld(w) of
      [v, newW]     -> [v:stack, st, newW]
                           esac                                 |
    LD(x)               -> [st(x):stack, st, w]                 |
    ST(x)               -> case stack of
      n:ns          -> [ns, st <- [x, n], w]
                           esac                                 |
    CONST(v)            -> [v:stack, st, w]                     |
    BINOP(op)           -> case stack of
      m:n:ns        -> [boMatch(op)(n, m):ns, st, w]
                           esac
  esac
}

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
fun eval (c, insns) {
  case insns of
    {}          -> c                            |
    i:is        -> eval(runUnit(c, i), is)
  esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval ([{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine instructions
fun compileExpr (expr) {
  case expr of
    Const (n)           -> {CONST(n)}                                              |
    Var (x)             -> {LD(x)}                                                 |
    Binop (op, e1, e2)  -> flatten({compileExpr(e1), compileExpr(e2), {BINOP(op)}})
  esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
  case stmt of
    Seq (s1, s2)        -> flatten({compileSM(s1), compileSM(s2)})                  |
    Read (x)            -> flatten({{READ}, {ST(x)}})                               |
    Write (expr)        -> flatten({compileExpr(expr), {WRITE}})                    |
    Skip                -> {}                                                       |
    Assn (x, expr)      -> flatten({compileExpr(expr), {ST(x)}})
  esac
}
