-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}



fun stropToBinop(l, op, r) {
  Binop(op, l, r)
}



var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ expr (
        {
          [Left, {[s("&&") | s("!!"), stropToBinop]}],
          [Left, {[s(">=") | s("==") | s("<=") | s ("!=") | s(">") | s("<"), stropToBinop]}],
          [Left, {[s("+") | s("-"), stropToBinop]}],
          [Left, {[s("*") | s("/") | s("%"), stropToBinop]}]
        }, primary
      );


--parser of if-elif-else sequence without if and fi
var ifStmt = memo $ eta syntax (
  e=exp kThen st=stmt {If(e, st, Skip)}                   |
  e=exp kThen st1=stmt kElse st2=stmt {If(e, st1, st2)}   |
  e=exp kThen st1=stmt kElif st2=ifStmt {If(e, st1, st2)}
);



var sngl = memo $ eta syntax (
  x=inbr[s("("), stmt, s(")")] {x}                              |
  kIf ifst=ifStmt kFi {ifst}                                    |
  kFor st1=stmt s[","] e=exp s[","] st2=stmt kDo st3=stmt kOd {
    Seq(st1, While(e, Seq(st3, st2)))
  }                                                             |
  kDo st=stmt kWhile e=exp kOd {DoWhile(st, e)}                 |
  kWhile x=exp kDo st=stmt kOd {While(x, st)}                   |
  kRead x=inbr[s("("), lident, s(")")] {Read(x)}                |
  kWrite x=inbr[s("("), exp, s(")")] {Write(x)}                 |
  kSkip {Skip}                                                  |
  x=lident s[":="] v=exp {Assn(x, v)}
);
var nonEndStmt = memo $ eta syntax (st=sngl {st} | le=sngl s[";"] ri=nonEndStmt {Seq(le, ri)});
var stmt = memo $ eta syntax (a=nonEndStmt {a});

-- Public top-level parser
public parse = stmt;
