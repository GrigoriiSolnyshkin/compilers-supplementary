import Fun;
import SM;
import Collection;
import List;
import Manifest;
import Buffer;

var regs = ["%ebx", "%ecx", "%esi", "%edi", "%eax", "%edx", "%ebp", "%esp"];

var nRegs = length(regs) - 5;

var ebx = R (0),
    ecx = R (1),
    esi = R (2),
    edi = R (3),
    eax = R (4),
    edx = R (5),
    ebp = R (6),
    esp = R (7);

var wordSize = 4;

fun insnString (insn) {
  
  fun binopString (op) {
    case op of
      "+"   -> "addl"
    | "-"   -> "subl"
    | "*"   -> "imull"
    | "&&"  -> "andl"
    | "!!"  -> "orl" 
    | "^"   -> "xorl"
    | "cmp" -> "cmpl"
    esac
  }

  fun opndString (opnd) {
    case opnd of
      R (i)    -> regs [i]
    | S (i)    ->  if i >= 0
                   then sprintf ("-%d(%%ebp)", (i+1) * wordSize)
                   else sprintf ("%d(%%ebp)", 8 + (-1-i) * wordSize)
                   fi
    | M (x)    -> x
    | L (i)    -> sprintf ("$%d", i)
    | I (0, x) -> sprintf ("(%s)", opndString (x))
    | I (n, x) -> sprintf ("%d(%s)", n, opndString (x))
    esac
  }

  case insn of
    Cltd               -> "\tcltd\n"
  | Set   (suf, s)     -> sprintf ("\tset%s\t%s\n", suf, s)
  | IDiv  (s1)         -> sprintf ("\tidivl\t%s\n", opndString (s1))
  | Binop (op, s1, s2) -> sprintf ("\t%s\t%s,\t%s\n", binopString (op), opndString (s1), opndString (s2))
  | Lea   (s1, s2)     -> sprintf ("\tleal\t%s,\t%s\n", opndString (s1), opndString (s2))
  | Mov   (s1, s2)     -> sprintf ("\tmovl\t%s,\t%s\n", opndString (s1), opndString (s2))
  | Push  (s)          -> sprintf ("\tpushl\t%s\n", opndString (s))
  | Pop   (s)          -> sprintf ("\tpopl\t%s\n", opndString (s))
  | Ret                -> "\tret\n"
  | Call  (p)          -> sprintf ("\tcall\t%s\n", p)
  | Label (l)          -> sprintf ("%s:\n", l)
  | Jmp   (l)          -> sprintf ("\tjmp\t%s\n", l)
  | CJmp  (c, l)       -> sprintf ("\tj%s\t%s\n", c, l)
  | Meta  (m)          -> m
  | Rishi (s1, s2)     -> sprintf ("\tsarl\t%s,\t%s\n", opndString(s1), opndString(s2))
  esac
}


fun makeEnv (stack, stackSlots, globals, strings, stringIndex, barrier, stackMap, fLabel, nLocals) {

  fun globalName (name) {
    "global_" ++ name
  }

  fun envString () {
    sprintf ("Stack     : %s\nStackSlots: %d\nGlobals   : %s\n", string(stack), stackSlots, string(elements(globals)))
  }
  
  fun allocate () {
    case 
      case stack of
        {}        -> [ebx, 0]
      | S (n) : _ -> [S (n+1), n+2]
      | R (n) : _ -> if n < nRegs then [R (n+1), stackSlots] else [S (nLocals), nLocals + 1] fi
      esac
    of [x, n] -> [x, makeEnv (x : stack, if n > stackSlots then n else stackSlots fi, globals, strings, stringIndex, barrier, stackMap, fLabel, nLocals)]esac
  }


  fun push (y) {
    makeEnv (y : stack, stackSlots, globals, strings, stringIndex, barrier, stackMap, fLabel, nLocals)
  }

  fun pop () {
    case stack of
      x : stack -> [x, makeEnv (stack, stackSlots, globals, strings, stringIndex, barrier, stackMap, fLabel, nLocals)]
    esac
  }

  fun pop2 () {
    case stack of
      x : y : stack -> [x, y, makeEnv (stack, stackSlots, globals, strings, stringIndex, barrier, stackMap, fLabel, nLocals)]
    esac
  }

  fun peek () {
    fst(stack)
  }
  
  fun addGlobal (name) {
    makeEnv (stack, stackSlots, addSet (globals, globalName (name)), strings, stringIndex, barrier, stackMap, fLabel, nLocals)
  }

  fun loc (alloc) {
    case alloc of
      Glb (x) -> M (globalName (x))
    | Arg (i) -> S (-1-i)
    | Loc (i) -> S (i)
    esac
  }
  
  fun getGlobals () {
    elements(globals)
  }

  fun getStackSize () {
    stackSlots
  }

  fun isBarrier () {
    barrier
  }

  fun setBarrier () {
    makeEnv (stack, stackSlots, globals, strings, stringIndex, true, stackMap, fLabel, nLocals)
  }

  fun setStack (l) {
    makeEnv (stack, stackSlots, globals, strings, stringIndex, false, addMap (stackMap, l, stack), fLabel, nLocals)
  }

  fun retrieveStack (l) {
    case findMap (stackMap, l) of
      None         -> makeEnv (stack, stackSlots, globals, strings, stringIndex, false, stackMap, fLabel, nLocals)
    | Some (stack) -> makeEnv (stack, stackSlots, globals, strings, stringIndex, false, stackMap, fLabel, nLocals)
    esac
  }

  fun enterFunction (fLabel, nL) {
    makeEnv (stack, nL, globals, strings, stringIndex, false, stackMap, fLabel, nL)
  }

  fun currentFunction () {
    fLabel
  }

  fun liveRegisters () {
    fun inner (acc, st) {
      case st of
        {}            -> acc
      | (r@R(_)) : tl -> inner (r : acc, tl)
      | _ : tl        -> inner (acc, tl)
      esac
    }

    inner ({}, stack)
  }

  fun addString (s) {
    var escaped = makeString ((length(s) + 1) * 2), i = 0, j = 0, name = sprintf ("string_%d", stringIndex);

    while i < length(s) do
      case s[i] of
        '"'  -> (escaped [j] :='"'); (escaped [j+1] := '"')
      | '\n' -> (escaped [j] :='\'); (escaped [j+1] := 'n')
      | '\t' -> (escaped [j] :='\'); (escaped [j+1] := 't')
      | c    -> (escaped [j] := c); (j := j-1)
      esac;
      j := j + 2; 
      i := i + 1
    od;
    
    [makeEnv (stack, stackSlots, globals, addSet (strings, [name, substring (escaped, 0, j)]), stringIndex+1, false, stackMap, fLabel, nLocals),
     name]
  }

  fun getStrings () {
    elements (strings)
  }

  fun staticSize () {
    stackSlots
  }

  fun getStack() {
    stack
  }
  
  [envString,
   allocate,
   push,
   pop,
   pop2,
   addGlobal,
   loc,
   getGlobals,
   getStackSize,
   peek,
   isBarrier,
   setBarrier,
   setStack,
   retrieveStack,
   enterFunction,
   currentFunction,
   liveRegisters,
   addString,
   getStrings,
   staticSize,
   getStack]
}

fun envString (env) {
  env [0] ()
}

fun allocate (env) {
  env [1] ()
}

fun push (env, x) {
  env [2] (x)
}

fun pop (env) {
  env [3] ()
}

fun pop2 (env) {
  env [4] ()
}

fun addGlobal (env, name) {
  env [5] (name)
}

fun loc (env, name) {
  env [6] (name)
}

fun getGlobals (env) {
  env [7] ()
}

fun getStackSize (env) {
  env [8] ()
}

fun peek (env) {
  env [9] ()
}

fun isBarrier (env) {
  env [10] ()
}

fun setBarrier (env) {
  env [11] ()
}

fun setStack (env, l) {
  env [12] (l)
}

fun retrieveStack (env, l) {
  env [13] (l)
}

fun enterFunction (env, fLabel, nL) {
  env [14] (fLabel, nL)
}

fun currentFunction (env) {
  env [15] ()
}

fun liveRegisters (env) {
  env [16] ()
}

fun addString (env, s) {
  env [17] (s)
}

fun getStrings (env) {
  env [18] ()
}

fun staticSize (env) {
  env [19] ()
}

fun getStack(env) {
  env[20] ()
}

fun initEnv () {
  makeEnv ({}, 0, emptySet (compare), emptySet (compare), 0, false, emptyMap (compare), "", 0)
}

fun codeSection (text) {
  singletonBuffer (Meta ("\t.text\n")) <+> text
}

fun dataSection (text) {
  singletonBuffer (Meta ("\t.data\n")) <+> text
}

fun intDef (name) {
  Meta (sprintf ("%s:\t.int\t0\n", name))
}

fun stringDef ([name, vl]) {
  Meta (sprintf ("%s:\t.string\t""%s""\n", name, vl))
}

fun prologue (fLabel) {
  singletonBuffer(Label (fLabel)) <+
  Push  (ebp) <+
  Mov   (esp, ebp) <+
  Binop ("-", M (sprintf ("$%s_SIZE", fLabel)), esp)  
}

fun epilogue (env) {
  var metaDef = Meta (sprintf ("\t.set\t%s_SIZE,\t%d\n", currentFunction(env), staticSize(env) * wordSize));

  if compare (currentFunction(env), "main") == 0
  then [env, singletonBuffer (Mov (ebp, esp)) <+ Pop (ebp) <+ Binop ("^", eax, eax) <+ Ret <+ metaDef]
  else case pop(env) of
         [y, env] -> [env, singletonBuffer (Mov (y, eax)) <+ Mov (ebp, esp) <+ Pop (ebp) <+ Ret <+ metaDef]
       esac
  fi
}

fun stackOpnd (opnd) {
  case opnd of
    S (_) -> true
  | _     -> false
  esac      
}

fun memOpnd (opnd) {
  case opnd of
    S (_)    -> true
  | M (_)    -> true
  | I (_, _) -> true
  | _        -> false
  esac
}

fun move (from, to) {
  if memOpnd (from) && memOpnd (to)
  then singletonBuffer (Mov (from, eax)) <+ Mov (eax, to)
  else singletonBuffer (Mov (from, to))
  fi
}

fun leaMove(from, to) {
  case to of
    R(_) -> singletonBuffer(Lea(from, to))
  | _ -> singletonBuffer(Lea(from, eax)) <+ Mov (eax, to)
  esac
}

fun suffix (op) {
  case op of
    "<"  -> "l"
  | "<=" -> "le"
  | "==" -> "e"
  | "!=" -> "ne"
  | ">=" -> "ge"
  | ">"  -> "g"
  esac
}

fun compile (env, code) {


  fun binopSimple(op, opnd1, opnd2) {
    case opnd1 of
      R(_) -> singletonBuffer(Binop(op, opnd2, opnd1)) |
      _ -> singletonBuffer(Mov(opnd1, eax)) <+ Binop(op, opnd2, eax) <+ Mov(eax, opnd1)
    esac
  }

  fun binopLogic(op, opnd1, opnd2) {
    binopCompare("!=", opnd1, L(0)) <+>
    binopCompare("!=", opnd2, L(0)) <+>
    case opnd1 of
      R(_) -> singletonBuffer(Binop(op, opnd2, opnd1)) |
      _ -> singletonBuffer(Mov(opnd1, eax)) <+ Binop(op, opnd2, eax) <+ Mov(eax, opnd1)
    esac
  }

  fun binopDiv(opnd1, opnd2) {
    singletonBuffer(Mov(opnd1, eax)) <+ 
    Cltd <+
    IDiv(opnd2) <+ 
    Mov(eax, opnd1)
  }

  fun binopMod(opnd1, opnd2) {
    singletonBuffer(Mov(opnd1, eax)) <+ 
    Cltd <+
    IDiv(opnd2) <+ 
    Mov(edx, opnd1)
  }

  fun binopCompare(op, opnd1, opnd2) {
      fun safeMov(s, d) {
        case s of R(_) -> emptyBuffer() | _ -> singletonBuffer(Mov(s, d)) esac
      }

      var syn1 = case opnd1 of R(_) -> opnd1 | _ -> eax esac,
          syn2 = case opnd2 of R(_) -> opnd2 | _ -> edx esac;
      
      safeMov(opnd1, syn1) <+>
      safeMov(opnd2, syn2) <+
      Binop("cmp", syn2, syn1) <+
      Mov(L(0), eax) <+
      Set(suffix(op), "%al") <+ 
      Mov(eax, opnd1)
  }

  fun cmpZero(opnd) {
    case opnd of
      R(_) -> singletonBuffer(Binop("cmp", L(0), opnd))
    | _ -> singletonBuffer(Mov(opnd, eax)) <+ Binop("cmp", L(0), eax)
    esac
  }

  fun isArithmeticOp(op) {
    case op of
      "*" -> true
    | "+" -> true
    | "-" -> true
    | _   -> false
    esac
  }

  fun isLogicOp(op) {
    case op of
      "!!" -> true
    | "&&" -> true
    | _   -> false
    esac
  }

  fun peekN(env, n) {
    fun topN(xs, n) {
      case n of
        0 -> {}
      | _ -> 
        case xs of
          x:xs -> x:topN(xs, n - 1)
        esac 
      esac
    }
    reverse(topN(getStack(env), n))
  }

  fun moveN(opnds) {
    case opnds of
      {} -> emptyBuffer()
    | opnd:opnds -> singletonBuffer(Push(opnd)) <+> moveN(opnds)
    esac
  }

  fun dropN(env, n) {
    case n of
      0 -> env
    | _ -> snd(pop(dropN(env, n - 1)))
    esac
  }

  fun deleteN(n) {
    if n then deleteN(n - 1) <+ Pop(edx) else emptyBuffer() fi
  } 

  fun returnN(opnds) {
    case opnds of
      {} -> emptyBuffer() 
    | opnd:opnds -> returnN(opnds) <+ Pop(opnd)
    esac
  }

  fun makeCall(name, nargs, env, code) {
      var liveRegs = liveRegisters(env), args = peekN(env, nargs);
      case allocate(dropN(env, nargs)) of
        [s, env] -> [env, 
                        code <+>
                        moveN(liveRegs) <+>
                        moveN(reverse(args)) <+>
                        singletonBuffer(Call(name)) <+>
                        deleteN(nargs) <+>
                        returnN(liveRegs) <+
                        Mov(eax, s)]
      esac
  }

  fun makeArrayCall(name, nargs, env, code) {
      var liveRegs = liveRegisters(env), args = peekN(env, nargs);
      case allocate(dropN(env, nargs)) of
        [s, env] -> [env, 
                        code <+>
                        moveN(liveRegs) <+>
                        moveN(reverse(args)) <+>
                        singletonBuffer(Push(L(nargs))) <+>
                        singletonBuffer(Call(name)) <+>
                        deleteN(nargs + 1) <+>
                        returnN(liveRegs) <+
                        Mov(eax, s)]
      esac
  }

  fun makeSexpCall(name, nargs, nm, env, code) {
      var liveRegs = liveRegisters(env), args = peekN(env, nargs);
      case allocate(dropN(env, nargs)) of
        [s, env] -> [env, 
                        code <+>
                        moveN(liveRegs) <+>
                        singletonBuffer(Push(L(tagHash(nm)))) <+>
                        moveN(reverse(args)) <+>
                        singletonBuffer(Push(L(nargs + 1))) <+>
                        singletonBuffer(Call(name)) <+>
                        deleteN(nargs + 2) <+>
                        returnN(liveRegs) <+
                        Mov(eax, s)]
      esac
  }

  foldl (
    fun ([env, scode], i) {
      var code = scode <+ Meta ("# " ++ showSMInsn (i) ++ "\n");

      case i of
        BEGIN (fLab, na, nl) ->
          [enterFunction(env, fLab, nl), code <+> prologue(fLab)]
      | CALL (fLab, nArgs) ->
          makeCall(fLab, nArgs, env, code)
      | GLOBAL (s) -> [addGlobal(env, s), code]
      | LD (x) ->
          case allocate(env) of
            [s, env] -> [env, code <+> move(loc(env, x), s)]
          esac
      | ST (x) ->
          case pop(env) of
            [s, env] -> [env, code <+> move(s, loc(env, x))]
          esac 
      | LDA(addr) ->
          case allocate(env) of
            [s, env] -> [env, code <+> leaMove(loc(env, addr), s)]
          esac
      | CONST(n) ->
          case allocate(env) of
            [s, env] -> [env, code <+> move(L(n), s)]
          esac
      | LABEL(lab) -> [retrieveStack(env, lab), code <+ Label(lab)]
      | JMP(lab) -> [setStack(env, lab), code <+ Jmp(lab)]
      | CJMP(lab) -> case pop(env) of
          [s, env] -> [setStack(env, lab), code <+> cmpZero(s) <+ CJmp("ne", lab)]
                     esac 
      | BINOP(op) ->
          case pop2(env) of
            [s2, s1, env] -> [push(env, s1), code <+>
              if isArithmeticOp(op) then binopSimple(op, s1, s2)
              elif isLogicOp(op) then binopLogic(op, s1, s2)
              else
                case op of
                  "/" -> binopDiv(s1, s2)
                | "%" -> binopMod(s1, s2)
                | _   -> binopCompare(op, s1, s2)
                esac
              fi
            ]
          esac
      | END ->
          case epilogue(env) of
            [env, epilogueCode] -> [env, code <+> epilogueCode]
          esac
      | DROP -> [snd(pop(env)), code]
      | DUP -> failure("DUP used")
      | STI -> 
          case pop2(env) of
            [s2, s1, env] -> [push(env, s1), code <+> move(s2, I(0, s1)) <+> move(s2, s1)]
          esac
      | BUILTIN(nm, nArgs) ->
          makeCall(stringcat({"L", nm}), nArgs, env, code)
      | STA ->
          makeCall("Bsta", 3, env, code)
      | ELEM ->
          makeCall("Belem", 2, env, code)
      | ARRAY(n) -> makeArrayCall("Barray", n, env, code)
      | SEXP(nm, n) -> makeSexpCall("Bsexp", n, nm, env, code)
      | STRING(s) ->
          case addString(env, s) of
            [env, sName] ->
              case allocate(env) of
                [ss, env] -> makeCall("Bstring", 1, env, code <+> leaMove(M(sName), ss))
              esac
          esac
      esac
    }, [env, emptyBuffer ()], code)
}

public fun compileX86 (args, code) {
  case compile (initEnv (), code) of
    [env, code] ->
       var asmFile = getBaseName(args) ++ ".s",
           runtime = case getEnv ("LAMA_RUNTIME") of
                       #val -> "../runtime/"
                     | path -> path
                     esac ++ "/runtime.o";

       fwrite (asmFile,
               stringcat(map (insnString, 
                    getBuffer(
                      singletonBuffer (Meta ("\t.global\tmain\n")) <+>
                      dataSection (listBuffer (map (intDef   , getGlobals (env))) <+>
                                   listBuffer (map (stringDef, getStrings (env)))) <+>
                      codeSection (code)                   
                    ))));
                    
       system (stringcat({"gcc -g -m32 -o ", getBaseName(args), " ", runtime, " ", asmFile}))
  esac
}
